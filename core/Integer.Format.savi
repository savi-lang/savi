:: Format the given integer value using one of the available format types.
:: Call one of the methods of this struct to choose which format type to use.
:struct val Integer.Format(T Integer(T)'val)
  :let _value T
  :new val _new(@_value)

  :fun decimal: Integer.Format.Decimal(T)._new(@_value)
  :fun hexadecimal: Integer.Format.Hexadecimal(T)._new(@_value)
  :fun binary: Integer.Format.Binary(T)._new(@_value)
  :fun unicode: Integer.Format.Unicode(T)._new(@_value)

  :fun dec: @decimal
  :fun hex: @hexadecimal
  :fun bin: @binary

:: Format the given integer into a variable number of decimal digits.
:struct val Integer.Format.Decimal(T Integer(T)'val)
  :is IntoString

  :let _value T
  :new val _new(@_value)

  :fun into_string(out String'iso) String'iso
    value = @_value

    // TODO: Avoid this hacky workaround for lack of numeric literals here.
    zero = value.zero
    one = value.one
    ten = one + one + one + one + one + one + one + one + one + one

    // Fast path for zero - it always has exactly one digit.
    if (value == zero) (
      out.push_byte('0')
      return --out
    )

    // If the value is less than zero, we need to negate it to make it positive
    // before we try to append its representation into the given string,
    // and we'll append a negative sign byte first.
    if (value < zero) (
      value = zero - value
      out.push_byte('-')
    )

    // Convert the value to a U64 so we don't have to specialize code by size.
    // TODO: It would likely be slightly faster to specialize by size here.
    u64 = value.u64

    // Get the number of digits to print and the initial divisor to use.
    digit_count = @_overestimated_digit_count(value.significant_bits)
    divisor = try (@_powers_of_10[(digit_count - 1).usize]! | 10)

    // For some numbers, our initial estimate is one higher than the correct
    // digit count, so in such cases we adjust our values down by one digit.
    if (u64 < divisor) (
      digit_count -= 1
      divisor = divisor / 10
    )

    // Print the digits from left to right (most to least significant).
    // This works because the divisor is decreasing by a factor of 10 each time.
    digit_count.times -> (
      out.push_byte((u64 / divisor % 10).u8 + '0')
      divisor = divisor / 10
    )

    --out

  :fun into_string_space USize
    orig_value = value = @_value

    // TODO: Avoid this hacky workaround for lack of numeric literals here.
    zero = value.zero

    // Fast path for zero - it always has exactly one digit.
    return 1 if (value == zero)

    // If the value is less than zero, we need to negate it to make it positive
    // before we try to count the number of its significant bits.
    if (value < zero) (value = zero - value)

    // The number of bytes we need available to print the number is the
    // same as the number of digits, with an added byte for the negative sign
    // in the case that the number is a negative one.
    digit_count = @_overestimated_digit_count(value.significant_bits)
    byte_count = if (orig_value < zero) (digit_count + 1 | digit_count)
    byte_count.usize

  :: Return a number which is greater than or equal to the number of base-10
  :: digits needed to represent the given value (which must be positive).
  :: This approximation will always be either exactly correct (as it is for the
  :: majority of possible numbers), or one higher than the correct digit count.
  :fun non _overestimated_digit_count(bit_count U8) U8
    // Take the number of significant bits, multiply by (77 / 256), then add 1.
    // This approximation is valid for up to 128 significant bits, and will not
    // overflow 16-bit intermediate computation, because 128 * 77 uses 14 bits.
    // Note that shifting by 8 bits is equivalent to floored division by 256.
    (bit_count.u16 * 77).bit_shr(8).u8 + 1

  :: All of the powers of 10 that are representable by the `U64` type,
  :: where the index of this table is used as the exponent of 10.
  :const _powers_of_10 Array(U64)'val: [
    1
    10
    100
    1000
    10000
    100000
    1000000
    10000000
    100000000
    1000000000
    10000000000
    100000000000
    1000000000000
    10000000000000
    100000000000000
    1000000000000000
    10000000000000000
    100000000000000000
    1000000000000000000
    10000000000000000000
  ]

:: Format the given integer into a fixed width hexadecimal representation.
::
:: By default the digits are shown with a "0x" prefix, but this is adjustable.
:struct val Integer.Format.Hexadecimal(T Integer(T)'val)
  :is IntoString

  :let _value T
  :let _prefix String
  :let _is_lowercase Bool
  :let _has_leading_zeros Bool
  :new val _new(
    @_value
    @_prefix = "0x"
    @_is_lowercase = True
    @_has_leading_zeros = True
  )

  :: Format without the standard "0x" hexadecimal prefix.
  :fun bare: @with_prefix("")

  :: Use the given prefix instead of the standard "0x" hexadecimal prefix.
  :fun with_prefix(prefix)
    @_new(@_value, prefix, @_is_lowercase, @_has_leading_zeros)

  :: Use lowercase hexadecimal letters (which is the default).
  :fun lowercase
    @_new(@_value, @_prefix, True, @_has_leading_zeros)

  :: Use uppercase hexadecimal letters instead of the default lowercase.
  :fun uppercase
    @_new(@_value, @_prefix, False, @_has_leading_zeros)

  :: Disable the default behavior of including all leading zeros.
  :fun without_leading_zeros
    @_new(@_value, @_prefix, @_is_lowercase, False)

  :fun into_string_space USize
    // TODO: different strategy when `_has_leading_zeros` is False.
    @_prefix.size + if (T.bit_width == 1) (1 | T.bit_width.usize / 4)

  :fun into_string(out String'iso) String'iso
    zeros = @_has_leading_zeros
    out << @_prefix
    case T.bit_width == (
    | 1 |
      digit = @_digit(0), out.push_byte(digit)
    | 8 |
      digit = @_digit(4), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(0), out.push_byte(digit)
    | 16 |
      digit = @_digit(12), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(8),  if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(4),  if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(0), out.push_byte(digit)
    | 32 |
      digit = @_digit(28), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(24), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(20), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(16), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(12), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(8),  if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(4),  if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(0), out.push_byte(digit)
    | 64 |
      digit = @_digit(60), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(56), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(52), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(48), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(44), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(40), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(36), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(32), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(28), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(24), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(20), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(16), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(12), if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(8),  if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(4),  if (zeros || digit != '0') (zeros = True, out.push_byte(digit))
      digit = @_digit(0), out.push_byte(digit)
    )
    --out

  :fun _digit(shr)
    u4 = @_value.bit_shr(shr).u8.bit_and(0xf)
    a = if @_is_lowercase ('a' | 'A')
    if (u4 <= 9) (u4 + '0' | u4 + a - 0xa)

:: Format the given integer into a fixed width binary representation.
::
:: By default the digits are shown with a "0b" prefix, but this is adjustable.
:struct val Integer.Format.Binary(T Integer(T)'val)
  :is IntoString

  :let _value T
  :let _prefix String
  :let _has_leading_zeros Bool
  :new val _new(
    @_value
    @_prefix = "0b"
    @_has_leading_zeros = True
  )

  :: Format without the standard "0b" binary prefix.
  :fun bare: @with_prefix("")

  :: Use the given prefix instead of the standard "0b" binary prefix.
  :fun with_prefix(prefix)
    @_new(@_value, prefix, @_has_leading_zeros)

  :: Disable the default behavior of including all leading zeros.
  :fun without_leading_zeros
    @_new(@_value, @_prefix, False)

  :fun into_string_space USize
    // TODO: different strategy when `_has_leading_zeros` is False.
    @_prefix.size + T.bit_width.usize

  :fun into_string(out String'iso) String'iso
    show_zeros = @_has_leading_zeros
    out << @_prefix

    // Begin with a bit mask highlighting only the single most significant bit.
    bit_mask = T.one.bit_shl(T.bit_width - 1)

    // Iterate the bit mask downward toward the lest significant bit until it
    // reaches zero, emitting the appropriate character to show each bit.
    while (bit_mask != T.zero) (
      if (@_value.bit_and(bit_mask) == T.zero) (
        if show_zeros out.push_byte('0')
      |
        show_zeros = True, out.push_byte('1')
      )
      bit_mask = bit_mask.bit_shr(1)
    )

    // If we haven't seen any zeros or ones yet, show at least one zero
    if !show_zeros out.push_byte('0')

    --out

:: Format the given integer as Unicode codepoint.
:struct val Integer.Format.Unicode(T Integer(T)'val)
  :is IntoString

  :let _value T

  :new val _new(@_value)

  :fun into_string(out String'iso) String'iso
    out.push_utf8(@_value.u32)
    --out

  :fun into_string_space USize
    // This is only a rough guess
    if (@_value.u32 < 128) (1 | 4)
