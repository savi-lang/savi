:class val Env
  :let out StdStream
  :let err StdStream
  :let args Array(String'val)
  :let vars EnvVars

  :new val _create(
    argc I32
    argv CPointer(CPointer(U8)'ref)'ref
    envp CPointer(CPointer(U8)'ref)'ref
  )
    @out = StdStream._out
    @err = StdStream._err

    @args = []
    i = USize[0]
    while (argc > 0) (
      arg = argv._get_at(i)
      len = InspectLibC.strlen(arg).usize
      @args.push(String.val_from_cpointer(arg, len, len))
      argc -= 1
      i += 1
    )

    @vars = EnvVars._from_envp(envp)

  :fun "exit_code="(value)
    LibPony.pony_exitcode(value)

:struct val EnvVars
  :let _vars Array(EnvVar)

  :new val _from_envp(envp CPointer(CPointer(U8)'ref)'ref)
    @_vars = []
    if (envp.is_not_null) (
      while True (
        arg = envp._get_at(0)
        break if arg.is_null

        try @_vars.push(EnvVar._from_cstring!(arg))

        envp = envp._offset(1)
      )
    )

  :fun each_pair
    :yields (String'val, String'val) for None
    @_vars.each_with_index -> (pair, _i |
      yield (pair.key, pair.value)
    )

  :fun "[]"(needle String) (String | None)
    @each_pair -> (key, value |
      return value if (needle == key)
    )
    None

  :fun "[]!"(needle String) String
    @[needle].as!(String)

:struct val EnvVar
  :let key String'val
  :let value String'val

  :new val _from_cstring!(cstring CPointer(U8)'ref)
    len = InspectLibC.strlen(cstring).usize
    pair = String.val_from_cpointer(cstring, len, len).split2!('=')
    @key = pair.first
    @value = pair.second

:actor StdStream
  :let _stream CPointer(None)'ref
  :new _out: @_stream = LibPony.pony_os_stdout
  :new _err: @_stream = LibPony.pony_os_stderr

  :: Write the given string to the stream, followed by a newline character.
  :be print(data String)
    LibPony.pony_os_std_print(@_stream, data.cpointer, data.size)

  :: Write the given string to the stream, without a newline character.
  :be write(data String)
    LibPony.pony_os_std_write(@_stream, data.cpointer, data.size)
