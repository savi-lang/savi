:import "IO"
:import "TCP"
:import "HTTPServer"

:actor Main
  :new (env)
    TCP.Listener.new(TCPSpecListenerNotify.new(env), "", "8080")

:class iso TCPSpecListenerNotify
  :is TCP.Listener.Notify
  :let env Env
  :new (@env)

  :fun ref listening(listen TCP.Listener'ref)
    @env.err.print("[Listener] Listening on port:")
    @env.err.print(Inspect[listen.local_port])

  :fun ref not_listening(listen TCP.Listener'ref) None
    @env.err.print("[Listener] Not listening:")
    @env.err.print(listen.listen_error.name)

  :fun ref closed(listen TCP.Listener'ref): None
    @env.err.print("[Listener] Stopped listening")

  :fun ref connected!(listen TCP.Listener'ref, ticket TCP.Listener.AcceptTicket)
    HTTPConnection.new(@env, listen, --ticket)

:actor HTTPConnection
  :is IO.Actor(IO.Action)
  :let env Env
  :let io TCP.ConnectionEngine
  :let reader: HTTPServer.RequestReader.new

  :new (@env, listen, ticket)
    @io = TCP.ConnectionEngine.accept(@, listen, --ticket)

  :fun ref _io_react(action IO.Action)
    case action == (
    | IO.Action.Read |
      @io.pending_reads -> (data |
        try (
          request = @reader.read!(@io.read_stream)

          response = HTTPServer.ResponseBuilder.new(@io.write_stream)

          response
            .status_ok
            .header("Content-Length", "0")
            .finish

          @io.flush
        )
      )
    | IO.Action.Write |
      @io.flush
    )
    @
