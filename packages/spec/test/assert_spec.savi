:class Foo
  :fun non true: True
  :fun non with_yield Bool
    yield False
    True

:class AssertSpec
  :is Spec
  :const describes: "Assert"

  :it "conforms to the `assert: EXPR` macro"
    assert: True
    assert: Foo.true
    assert: (True == Foo.true)
    assert: False.is_false
    assert: \
      True
    assert: Foo.with_yield -> (false |
      assert: !false
    )

  :it "conforms to the `assert: EXP1 <op> EXP2` macro"
    assert: True == True
    assert: Foo.true == True
    assert: True == Foo.true
    assert: True \
      == True
    assert: Foo.with_yield -> (false |
      assert: !false) == Foo.true

  :fun maybe_string1 (String | None): None
  :fun maybe_string2 (String | None): String.new_iso
  :it "conforms to the `assert: EXP1 <: EXP2` and `assert: EXP1 !<: EXP2` cases"
    assert: @maybe_string1 !<: String
    assert: @maybe_string2 <: String
    assert: [@maybe_string1] <: Array((String | None))
  // TODO: we need to implement <: for union types
  // assert: True <: (String | Bool)

  :it "honors iso"
    assert: "" == String.new_iso

    foo = String.new_iso, foo << "foo"
    assert: "foo" == --foo
