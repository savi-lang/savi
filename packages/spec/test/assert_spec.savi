:import "collections" (Map)

:module Foo
  :fun non true: True
  :fun non with_yield Bool
    yield False
    True
  :fun non fail! Bool: error!, True

:module Something
  :fun non dangerous!: "not really"
  :fun non break!: error!

:class AssertSpec
  :is Spec
  :const describes: "Assert"

  :it "conforms to the `assert: EXPR` macro"
    assert: True
    assert: Foo.true
    assert: (True == Foo.true)
    assert: False.is_false
    assert: \
      True
    assert: Foo.with_yield -> (false |
      assert: !false
    )

  :it "conforms to the `assert: EXP1 <op> EXP2` macro"
    assert: True == True
    assert: Foo.true == True
    assert: True == Foo.true
    assert: True \
      == True
    assert: Foo.with_yield -> (false |
      assert: !false) == Foo.true

  :fun maybe_string1 (String | None): None
  :fun maybe_string2 (String | None): String.new_iso
  :it "conforms to the `assert: EXP1 <: EXP2` and `assert: EXP1 !<: EXP2` cases"
    assert: @maybe_string1 !<: String
    assert: @maybe_string2 <: String
    assert: [@maybe_string1] <: Array((String | None))
  // TODO: we need to implement <: for union types
  // assert: True <: (String | Bool)

  :it "honors iso"
    assert: "" == String.new_iso

    foo = String.new_iso, foo << "foo"
    assert: "foo" == --foo

  :it "conforms to the `assert no_error: EXP` macro"
    map = Map(String, U64).new, map["example"] = 1
    assert no_error: map["example"]!
    assert no_error: map["example"]! == 1

    assert no_error: Something.dangerous!

  :it "conforms to the `assert error: EXP` macro"
    map = Map(String, U64).new
    assert error: map["example"]!

    assert error: Something.break!
