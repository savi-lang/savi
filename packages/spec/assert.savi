:trait val Assert
  :let spec String
  :let example String
  :let success Bool
  :let pos SourceCodePosition

  :: The print_failure function will print a specific failure message \
  :: for the different kinds of assertions.
  :fun print_failure(env Env) None

  :fun non condition(
    spec Spec
    success Bool
    pos SourceCodePosition = source_code_position_of_argument spec
  )
    ctx = spec.ctx
    assert = AssertCondition.new(
      ctx.spec
      ctx.example
      success
      pos
    )
    ctx.specs.enqueue(assert)

  :fun non relation(
    spec Spec
    op String
    lhs Any'box
    rhs Any'box
    success Bool
    pos SourceCodePosition = source_code_position_of_argument spec
  )
    ctx = spec.ctx
    assert = AssertRelation.new(
      ctx.spec
      ctx.example
      success
      pos
      op
      Inspect[lhs]
      Inspect[rhs]
    )
    ctx.specs.enqueue(assert)

  :fun non type_relation(
    spec Spec
    op String
    lhs Any'box
    rhs String
    success Bool
    pos SourceCodePosition = source_code_position_of_argument spec
  )
    ctx = spec.ctx
    assert = AssertTypeRelation.new(
      ctx.spec
      ctx.example
      success
      pos
      op
      Inspect[lhs]
      rhs
    )
    ctx.specs.enqueue(assert)

  :fun non has_error(
    spec Spec
    has_error Bool
    expects_error Bool
    pos SourceCodePosition = source_code_position_of_argument spec
  )
    ctx = spec.ctx
    assert = AssertHasError.new(
      ctx.spec
      ctx.example
      if expects_error (has_error | !has_error)
      pos
      expects_error
    )
    ctx.specs.enqueue(assert)

  :fun file_and_line String
    line = Inspect[@pos.row + 1]
    @indent(4, String.join(["# ", @pos.filename, ":", line]))

  :fun indent(times USize, msg String) String
    String.join([" " * times, msg])

:class val AssertCondition
  :is Assert

  :new val (@spec, @example, @success, @pos)

  :fun print_failure(env Env) None
    env.err.print(String.join([
      ""
      @indent(4, String.join(["FAIL:", @pos.string], " "))
      ""
      @indent(4, "Expected to be True")
      ""
      @file_and_line
    ], "\n"))

    None

:class val AssertRelation
  :is Assert

  :let op String
  :let lhs String
  :let rhs String

  :new val (@spec, @example, @success, @pos, @op, @lhs, @rhs)

  :fun print_failure(env Env) None
    env.err.print(String.join([
      ""
      @indent(4, String.join(["FAIL:", @pos.string], " "))
      ""
      @indent(4, "Expected")
      @indent(6, @lhs)
      @indent(4, String.join(["to ", @op]))
      @indent(6, @rhs)
      ""
      @file_and_line
    ], "\n"))

    None

:class val AssertTypeRelation
  :is Assert

  :let op String
  :let lhs String
  :let rhs String

  :new val (@spec, @example, @success, @pos, @op, @lhs, @rhs)

  :fun print_failure(env Env) None
    expectation = if (@op == "<:") ("to be a subtype of" | "not to be a subtype of")

    env.err.print(String.join([
      ""
      @indent(4, String.join(["FAIL:", @pos.string], " "))
      ""
      @indent(4, String.join([
        "Expected"
        @lhs
        expectation
        @rhs
      ], " "))
      ""
      @file_and_line
    ], "\n"))

    None

:class val AssertHasError
  :is Assert

  :let expects_error Bool

  :new val (@spec, @example, @success, @pos, @expects_error)

  :fun print_failure(env Env) None
    expectation = if @expects_error (
      "Expected to raise an error"
    |
      "Not expected to raise an error"
    )

    env.err.print(String.join([
      ""
      @indent(4, String.join(["FAIL:", @pos.string], " "))
      ""
      @indent(4, expectation)
      ""
      @file_and_line
    ], "\n"))

    None
