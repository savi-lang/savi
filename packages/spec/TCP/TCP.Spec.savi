:class iso TCP.Spec.Listener.Notify
  :is TCP.Listener.Notify
  :let env Env
  :new (@env)

  :fun ref listening(listen TCP.Listener'ref)
    TCP.Spec.EchoClient.new(@env, Inspect[listen.local_port])
    @env.err.print("[Listener] Listening")

  :fun ref not_listening(listen TCP.Listener'ref) None
    @env.err.print("[Listener] Not listening:")
    @env.err.print(listen.listen_error.name)

  :fun ref closed(listen TCP.Listener'ref): None
    @env.err.print("[Listener] Stopped listening")

  :fun ref connected!(listen TCP.Listener'ref, ticket TCP.Listener.AcceptTicket)
    TCP.Spec.Echoer.new(@env, listen, --ticket)

:actor TCP.Spec.Echoer
  :is IO.Actor(IO.Action)
  :let env Env
  :let io TCP.ConnectionEngine
  :new (@env, listen, ticket)
    @io = TCP.ConnectionEngine.accept(@, listen, --ticket)
    @env.err.print("[Echoer] Accepted")

  :fun ref _io_react(action IO.Action)
    case action == (
    | IO.Action.Read |
      @io.pending_reads -> (bytes_available |
        @io.read_stream.advance_to_end
        bytes val = @io.read_stream.extract_token
        @env.err.print("[Echoer] Received:")
        @env.err.print(bytes.as_string)
        @io.write_stream << bytes.clone // TODO: is clone still needed?
        @io.flush // TODO: should we flush automatically on close below?
        @io.close
      )
    | IO.Action.Closed |
      @env.err.print("[Echoer] Closed")
      try @io.listen.as!(TCP.Listener).dispose
    )
    @

:actor TCP.Spec.EchoClient
  :is IO.Actor(IO.Action)
  :let env Env
  :let io TCP.ConnectionEngine
  :new (@env, service)
    @io = TCP.ConnectionEngine.connect(@, "localhost", service)

    // TODO: Can we make this trigger _io_react with IO.Action.OpenFailed
    // automatically via the same mechanism we will use for queuing later
    // pending reads, instead of checking for this error case here?
    if (@io.connect_error != OSError.None) (
      @env.err.print("[EchoClient] Failed to connect:")
      @env.err.print(@io.connect_error.name)
    )

  :fun ref _io_react(action IO.Action)
    case action == (
    | IO.Action.Opened |
      @env.err.print("[EchoClient] Connected")
      @io.write_stream << b"Hello, World!"
      @io.flush

    | IO.Action.OpenFailed |
      @env.err.print("[EchoClient] Failed to connect:")
      @env.err.print(@io.connect_error.name)

    | IO.Action.Read |
      @io.pending_reads -> (bytes_available |
        if (bytes_available >= b"Hello, World!".size) (
          @io.read_stream.advance_to_end
          @env.err.print("[EchoClient] Received:")
          @env.err.print(@io.read_stream.extract_token.as_string)
          @io.close
        )
      )

    | IO.Action.Closed |
      @env.err.print("[EchoClient] Closed")
      try @io.listen.as!(TCP.Listener).dispose
    )
    @

:class TCP.Spec
  :is Spec
  :const describes: "TCP"

  :it "can listen, connect, send, respond, disconnect, and stop listening"
    TCP.Listener.new(TCP.Spec.Listener.Notify.new(@env))
