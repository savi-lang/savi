// The state table in this file has been taken from a third-party source,
// The copyright statement and MIT license for it being reproduced below.
// See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
//
// Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software")
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

:: This module can be used collaboratively with the caller to decode UTF-8.
::
:: It uses a DFA (deterministic finite automaton) state machine, with the
:: caller maintaining state on the calling side, so that the module itself
:: can be stateless, avoiding the need for it to be allocated.
::
:: The general-purpose usage looks like this:
::
:: ```savi
:: codepoint U32 = 0
:: state U8 = 0
::
:: bytes.each -> (byte |
::   codepoint = UTF8Decoding.read_byte_into_codepoint(byte, state, codepoint)
::   state = UTF8Decoding.next_state(byte, state)
::
::   if (state == 0) (yield codepoint)
::   if UTF8Decoding.is_error_state(state) error!
:: )
:: ```
::
:: See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details on the DFA.
::
:module UTF8Decoding // TODO: make this private or rename the file
  // See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.
  :const _type_table_data Array(U8)'val: [
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 00..0f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 10..1f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 20..2f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 30..3f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 40..4f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 50..5f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 60..6f
    0,   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 70..7f
    1,   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // 80..8f
    9,   9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9 // 90..9f
    7,   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 // a0..af
    7,   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7 // b0..bf
    8,   8, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 // c0..cf
    2,   2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 // d0..df
    0xa, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 3 // e0..ef
    0xb, 6, 6, 6, 5, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 // f0..ff
  ]
  // The next state is looked up by reaching into the state table as if it
  // were a two-dimensional table of 16 rows and 16 columns, with the
  // state being the row index and the byte type being the column index
  //
  // But fewer than 16 byte types are actually defined in the type table,
  // so those columns in the state table all lead to the error state.
  //
  // Similarly, fewer than 16 state types are in use, so the latter rows
  // of the table also lead to the error state.
  :const _state_table_data Array(U8)'val: [
    0, 1, 2, 3, 5, 8, 7, 1, 1, 1, 4, 6, 1, 1, 1, 1 // s0
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s1
    1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1 // s2
    1, 2, 1, 1, 1, 1, 1, 2, 1, 2, 1, 1, 1, 1, 1, 1 // s3
    1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1 // s4
    1, 2, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1 // s5
    1, 1, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1 // s6
    1, 3, 1, 1, 1, 1, 1, 3, 1, 3, 1, 1, 1, 1, 1, 1 // s7
    1, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // s8
    // We pad with enough extra bytes in the table to fill an entire 256,
    // so that we can be sure of memory safety in our direct pointer indexing
    // even if for some reason our logic in the functions below is not correct.
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // (unused)
  ]

  // Since we're in the core Savi package, we can cheat a bit here and do
  // direct pointer indexing for a performance improvement, knowing that
  // both tables have a size of 256, so direct indexing with a U8 index
  // will not be able to cause any memory safety issues.
  :fun _type_table(byte U8) U8: @_type_table_data._ptr._get_at(byte.usize)
  :fun _state_table(type U8, state U8) U8
    @_state_table_data._ptr._get_at((type + state * 16).usize)

  :: Return the codepoint (or partial codepoint in progress) based on the
  :: given incoming byte, state value, and any existing partial codepoint value.
  ::
  :: When starting a new codepoint
  :fun read_byte_into_codepoint(byte U8, state U8, existing_codepoint U32) U32
    if (state == 0) (
      // When state is zero, this is considered to be an initial byte,
      // so we need to determine its type and mask it appropriately.
      // The UTF-8 encoding specification defines different data mask sizes
      // for leading bytes, which we correlate to byte types in the type table
      // to know how many bits to mask.
      type = @_type_table(byte)
      mask = U8[0xff].bit_shr(type)
      byte.bit_and(mask).u32
    |
      // Otherwise this is a continuation byte, so we mask it as such
      // and join it to the existing bits, shifted to make room for new bits.
      byte.bit_and(0x3f).u32.bit_or(existing_codepoint.bit_shl(6))
    )

  :: Return the next state in the UTF-8 decoding state machine,
  :: based on the current state and the newly received byte.
  :fun next_state(byte U8, current_state U8)
    @_state_table(@_type_table(byte), current_state)

  // Errors are indicated by state 1 in the state table.
  :fun is_error_state(state U8): state == 1

  // The state table has been designed such that integer division by 3
  // gives the number of bytes left in the current codepoint's encoded bytes.
  :fun remaining_bytes_for_codepoint(state U8) U8: state / 3
