:: This class provides a way to buffer writes to a data sink, in the form of
:: chunks that arrive one at a time, then get flushed all together to the sink.
::
:: This batched writing pattern amortizes the cost of writing to the sink.
:: but its up to the caller to determine when to `flush`, based on whatever
:: performance tuning and/or heuristics deemed appropriate for the application.
:class ByteStream.Writer
  :is ByteStream.Writable

  :let target ByteStream.Sink
  :new (@target)

  :new to_reader(reader ByteStream.Reader)
    @target = ByteStream.Sink.ToReader.new(reader)

  :: Add a chunk of bytes to the stream.
  ::
  :: It won't actually get written until the `flush` method is called.
  :fun ref "<<"(chunk Bytes'val)
    @target.write_bytes(chunk)
    @

  :: Add a single byte to the stream.
  ::
  :: It won't actually get written until the `flush` method is called.
  :fun ref push(byte U8)
    @target.write_bytes(Bytes.new_iso.push(byte)) // TODO: more efficient
    @

  :: Try to write all data that is currently buffered to the `target` sink.
  ::
  :: Raises an error if there is still some data buffered that could not yet be
  :: flushed, either because the underlying sink was not in a writable state,
  :: or because it wasn't prepared to accept the full amount yet.
  ::
  :: However, note that even if an error is raised, there may have been some
  :: amount of successful data transfer already - all that is known is that
  :: some amount of data still remains in the internal buffer to be transferred.
  :fun ref flush! @
    @target.write_flush!
    @
